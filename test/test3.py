# auto-generated by nosebug (https://github.com/kmanley/nosebug.git)
import cgi
import StringIO
html_escape = cgi.escape
    
def get_ctx_value(stack, path):
    # current context is at stack[-1]
    print "stack: %s" % repr(stack) # TODO:
    print "path: %s" % repr(path) # TODO:
    parts = path.split("/")
    idx = -1
    curr = stack[idx]
    for part in parts:
        # Note: the parser ensures the path is well-formed
        if part == "..":
            idx -= 1
            curr = stack[idx]
        else:
            curr = curr.get(part)
    return curr

def start_section(stack, path):
    temp = get_ctx_value(stack, path) or []
    if type(temp) not in (list, tuple):
        temp = [temp]
    return temp
 
def iter_test3(d):
    stack = [d]
    l1 = start_section(stack, 'foo')
    if type(l1) == dict:
        stack.append(l1)
    for ll1 in l1:
        if type(ll1) == dict:
            stack.append(ll1)
        yield '\n  '
        l2 = start_section(stack, 'bar')
        if type(l2) == dict:
            stack.append(l2)
        for ll2 in l2:
            if type(ll2) == dict:
                stack.append(ll2)
            yield '\n    baz is '
            yield html_escape(unicode(stack[-1].get('baz', '')))
            yield '\n    qux is '
            yield html_escape(unicode(get_ctx_value(stack, '../qux')))
            yield ' \n  '
            if type(ll2) == dict:
                stack.pop()
        if type(l2) == dict:
            stack.pop()
        yield '\n  qux again is '
        yield html_escape(unicode(stack[-1].get('qux', '')))
        yield ' \n'
        if type(ll1) == dict:
            stack.pop()
    if type(l1) == dict:
        stack.pop()
    yield '\nand once again qux is '
    yield html_escape(unicode(get_ctx_value(stack, 'foo/qux')))
    yield '\n\n'
    
def test3(d): 
    o = StringIO.StringIO()
    for chunk in iter_test3(d):
        o.write(chunk)
    return o.getvalue()

