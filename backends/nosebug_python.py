# TODO: proper unicode handling...
import os
from nosebug_base import BackendBase

class INDENT : pass
class DEDENT : pass

FILE_HEADER = """\
# auto-generated by nosebug (https://github.com/kmanley/nosebug.git)
def html_escape(s):
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;").replace("'", "&#39;")
    
def get_ctx_value(stack, path):
    # current context is at stack[-1]
    #print "stack: %s" % repr(stack) # TODO:
    #print "path: %s" % repr(path) # TODO:
    parts = path.split("/")
    idx = -1
    curr = stack[idx]
    for part in parts:
        # Note: the parser ensures the path is well-formed
        if part == "..":
            idx -= 1
            curr = stack[idx]
        else:
            curr = curr.get(part)
    if callable(curr):
        #print 'CALLING CALLABLE %s' % path, repr(stack)
        return curr(stack)
    else:
        return curr

def start_section(stack, path):
    temp = get_ctx_value(stack, path) or []
    if type(temp) not in (list, tuple):
        temp = [temp]
    #print "start section %s returns %s" % (path, repr(temp)) # TODO:        
    return temp
 
"""

TEMPLATE_END = """
def %(func_name)s(d):
    import pprint
    x = list(iter_%(func_name)s(d))
    pprint.pprint(x) 
    #return "".join(iter_%(func_name)s(d))
    return "".join(x)
"""

class Backend(BackendBase):
    
    def __init__(self, *args, **kwargs):
        BackendBase.__init__(self, *args, **kwargs)
        self._indent = ""
        
    def get_extension(self):
        return "py"
    
    def get_ctx_value(self, path, level):
        if path == ".":
            return "ll%d" % level
        else:
            # always call get_ctx_value since target may be a callable
            return "get_ctx_value(stack, %s)" % repr(path)
        #if "/" in path:
        #    return "get_ctx_value(stack, %s)" % repr(path)
        #else:
        #    return "stack[-1].get(%s, '')" % repr(path)
            #return "stack[-1][%s]" % repr(path)

    def write(self, fp, *args):
        for item in args:
            if item == INDENT:
                self._indent += (" " * 4)
            elif item == DEDENT:
                self._indent = self._indent[:-4]
            else:
                fp.write("%s%s\n" % (self._indent, item))
        
    def ON_FILE_START(self, fp, file_name):
        fp.write(FILE_HEADER)

    def ON_TEMPLATE_START(self, fp, func_name):
        #func_name = os.path.splitext(os.path.split(file_name)[-1])[0]
        self.write(fp, "def iter_%s(d):" % func_name,  
                       "    stack = [d]", INDENT)
    
    def ON_STRING(self, fp, s, level):
        self.write(fp, "yield %s" % repr(s))
    
    def ON_TAG_SECTION_START(self, fp, path, level):
        self.write(fp, "l%d = start_section(stack, %s)" % (level, repr(path)),
                       "if type(l%d) == dict:" % level,
                       "    stack.append(l%d)" % level,
                       "for ll%d in l%d:" % (level, level),
                       "    if type(ll%d) == dict:" % level, 
                       "        stack.append(ll%d)" % level, INDENT)

    def ON_TAG_INV_SECTION_START(self, fp, path, level):
        pass
    
    def ON_TAG_SECTION_END(self, fp, path, level):
        self.write(fp, "if type(ll%d) == dict:" % (level+1),
                       "    stack.pop()", DEDENT,
                       "if type(l%d) == dict:" % (level+1),
                       "    stack.pop()")
    
    def ON_TAG_PARTIAL(self, fp, name, level):
        self.write(fp, "yield %s(stack[-1])" % name)
    
    def ON_TAG_VAR_UNESCAPED(self, fp, path, level):
        self.write(fp, "yield unicode(%s)" % self.get_ctx_value(path, level))
    
    def ON_TAG_VAR_ESCAPED(self, fp, path, level):
        # TODO: actually do the escaping
        self.write(fp, "yield html_escape(unicode(%s))" % self.get_ctx_value(path, level))
    
    def ON_TEMPLATE_END(self, fp, func_name):
        #func_name = os.path.splitext(os.path.split(file_name)[-1])[0]
        self.write(fp, TEMPLATE_END % dict(func_name=func_name), DEDENT)
    
    def ON_FILE_END(self, fp, file_name):
        pass 
        
    
